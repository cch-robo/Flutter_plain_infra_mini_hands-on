# ミニハンズオンまとめ

このミニハンズオン **"Flutter アプリ インフラ入門（Dependency Injection）"** の冒頭では、  

**アプリを多くの人に使ってもらえるようにするには、ニーズの変化やエラーをいち早く知り、  
ピボットに素早く対応できるよう、変更や拡張やテストを容易にする仕組みが必要** ...なことを述べました。  

Dependency Injection (依存性注入)を体験していただいて、  
機能要件の開発に必要となるテストや Crashlytics にデバッグログ出力、  
機能要件にないニーズや変化を知るための Analytics ログ記録などの手段として  
Dependency Injection や DIコンテナが利用できそうと感じていただけましたでしょうか。  


## ミニハンズオンで体験した<br/>Dependency Injection (依存性注入)の基本

1. アプリの機能要望について、 **要件仕様のインターフェース**を定義する。
2. インターフェースの実装は、機能実現の**依存元クラス**と、依存元のラッパーである**注入先クラス**に分ける。
3. それらクラスはプライベート・コンストラクタとし、オブジェクト生成と依存注入まで、**DIコンテナに一任**させる。
4. アプリには、注入先オブジェクトを束縛させ、**依存元の参照および外部からの差替は、テスト時に動的に行える**ようにする。
5. 要件の追加は、**DIコンテナの多段階依存注入(追加の注入先を作って依存元を注入し、アプリに束縛させる注入先に注入させる)で対応**する。

- _DIコンテナで、依存元と注入先のオブジェクト生成と依存注入および、生成オブジェクトの保持管理を行わせることで、  
アプリに注入先をバインドさせたまま、テスト時において内部の依存元オブジェクトを動的に参照や差替可能にしています。_

- DIコンテナに機能実装オブジェクトの生成を一任することは、  
コードリーディングにおける **「密結合を避けて疎結合にしたアーキテクチャの実態確認負荷」** への一つの回答にもなっています。<br/>  
・_クラス・フィールドの型が、機能仕様インターフェースであっても、  
　そのバインド実態は、DIコンテナのオブジェクト生成部(依存注入部)の確認で済みます。_<br/>  
・_プライベート・コンストラクタにした依存元クラスと注入先クラスと、それらを生成する DIコンテナは、  
　1つのパッケージに集約されるので、凝集度を上げることにもつながっています。_<br/>

- **注意事項**  
**動的な依存元の参照及び差替は、アプリ内のコードで絶対に行わせないようにしてください。**  
アプリ実行中に動的操作が行われているか否かを確認するため、  
`CounterDiContainer`には、動的操作禁止要請フラグ `isNoUseDynamicOperation`を設けています。  
_フラグを`true`に設定すれば、動的操作が禁止され、アプリ内で動的操作されているコードが実行されるとエラーが発生します。_  
_step_2 〜 Step_4 テストコードの main関数の先頭行に `CounterDiContainer.isNoUseDynamicOperation = true;` を追加すれば、  
エラーが発生してテストに失敗することが確認できます。_


## ミニハンズオンの発展
- 簡易DIコンテナと依存元と注入先の基底インターフェースや基盤クラスについては、  
  [lib/src/infra/dependency_injector.dart](../infra/dependency_injector.dart) を御参照ください。  

- テスト設計については、拙セッション資料 [Flutter テスト講座 テスト設計できるようになろう](https://drive.google.com/file/d/1OznsKYxa_VSkrAwuH2cqpf1ZHxBNsLEg/view) を参照いただければ幸いです。  


### ミニハンズオン時間が余った方へ
`step_5`には、Android コントリビューター一覧を取得する REST API のサンプル実装があります。  
この REST API を使って、画面にコントリビューター一覧や詳細を表示させるように改修してみてはいかがでしょう。 🤓  
